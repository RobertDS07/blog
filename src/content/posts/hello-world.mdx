---
title: 'Bem-vindo'
imageUrl: '/images/articles/welcome/cover.jpg'
description: 'Contando um pouco de como foi a constru√ß√£o deste site, quais tecnologias utilizei, porqu√™ escolhi elas e muito mais.'
timeToReadInMinutes: 8
tags: ['astro', 'solid', 'aws']
createdAt: '2023/08/09'
---
Ol√° e bem-vindo ao meu site! √â um prazer t√™-lo aqui. Neste espa√ßo, compartilharei uma variedade de t√≥picos que me interessam, abrangendo n√£o apenas programa√ß√£o, mas tamb√©m sa√∫de, vida e outros assuntos. Este site tamb√©m oferece uma oportunidade de me conhecer melhor. Al√©m disso, aguardam duas funcionalidades futuras: uma linha do tempo da minha jornada na programa√ß√£o e uma se√ß√£o de links √∫teis.

Vamos agora ao tema deste post, que √© a cria√ß√£o deste pr√≥prio site que voc√™ est√° agora. Nesta postagem, compartilharei as decis√µes que tomei, as tecnologias que escolhi, as metodologias que apliquei e outros detalhes interessantes. Espero que voc√™ aproveite este conte√∫do e que eu possa ensinar algo novo ou mostrar algo que voc√™ ainda n√£o sabia.

# Tecnologias Utilizadas

Para come√ßar, vamos falar sobre a stack que decidi utilizar.

## [Astro](https://astro.build/)

O Astro √© o cora√ß√£o deste projeto e uma escolha que me empolgou desde o in√≠cio. Quero destacar algumas de suas principais caracter√≠sticas:

### 1. [Ilha de componentes](https://docs.astro.build/en/concepts/islands/)

Qual √© o maior problema enfrentado hoje pelos frameworks mais famosos do mercado? O que fez o Next ficar t√£o famoso (um dos motivos)? Por que o React est√° investindo em Server Components h√° tanto tempo?

Exato... O problema √© o envio de Javascript para o Front End. As ilhas de componentes v√™m para resolver esse problema, permitindo que o desenvolvedor decida o que ser√° e o que n√£o ser√° enviado de Javascript para o Front End. Isso significa que, se um componente √© interativo (usa Javascript) e voc√™ n√£o avisar ao Astro que o Javascript contido nele deve ser enviado para o cliente, ele n√£o ser√° e, por consequ√™ncia, n√£o ser√° interativo. Resumindo, o Astro tem o pilar de `zero client-side JavaScript, por padr√£o`.

Abaixo est√° uma imagem que ilustra alguns dos diferentes m√©todos de renderiza√ß√£o.

<img src="/images/articles/welcome/diff-methods-to-render-fe.png" alt="Foto contendo algumas das diferentes formas de renderiza√ß√£o que existem no front-end." />

### 2. Agnostico de UI

O Astro n√£o limita o uso a um √∫nico framework. Ele suporta React, Vue, Preact, Solid e outros. Voc√™ pode at√© misturar componentes de diferentes frameworks.

```js
// pages/some-page.astro

---
import SomeVueComponent from '../components/SomeVueComponent.vue';
import SomeReactComponent from '../components/SomeReactComponent.jsx';
---

<SomeVueComponent />
<SomeReactComponent />
```

### 3. Focado em conte√∫do

Por pen√∫ltimo, pois n√£o quero me estender muito aqui no Astro que j√° estou me estendendo... Ele tem um foco muito grande na gera√ß√£o de conte√∫do. Pelo fato de eu querer come√ßar a escrever, isso foi o que mais me chamou a aten√ß√£o.

Dentro do diret√≥rio /src, temos uma pasta chamada content, onde est√£o todos os nossos conte√∫dos est√°ticos, normalmente em .md ou .mdx. A partir dessa pasta, o Astro oferece uma s√©rie de recursos, como:

1. Listar o conte√∫dos filtrando
2. Defini√ß√£o de schemas com zod por padr√£o, para garantir a integridade dos dados inseridos l√°
3. Refer√™ncia de outros artigos de forma simples

### 4. Performance

E, por √∫ltimo (eu juro que √© o √∫ltimo do Astro), temos a performance, uma das coisas mais importantes para blogs. O Astro traz o pilar de zero javascript, como mencionado anteriormente. Mesmo usando bibliotecas que facilitam a cria√ß√£o de UIs com javascript, ainda podemos ter um desempenho muito bom. Abaixo, deixarei uma imagem disponibilizada no site do Astro.

<img src="/images/articles/welcome/astro-performance-comparison.png" alt="Foto contendo imagem disponibilizada no site do Astro onde mostram um teste de performance onde o astro foi muito bem." />

O link para ver como foram feitos os testes de performance est√£o [aqui](https://astro.build/blog/2023-web-framework-performance-report/).

## [Solid.js](https://www.solidjs.com/)

Passando para a pr√≥xima tecnologia em nossa stack, temos o Solid. Demorei um pouco para escolher o Solid, pois estava procurando por uma biblioteca r√°pida e eficiente para lidar com a reatividade no meu site. Considerei v√°rias op√ß√µes, como Preact, Solid, Svelte, Lit, HyperHTML e, claro, React...

Primeiro, uma breve apresenta√ß√£o do Solid para voc√™s. O Solid √© um framework relativamente novo, com registros de vers√µes lan√ßadas em seu reposit√≥rio p√∫blico a partir de 2019. Para voc√™ ter uma ideia de qu√£o recente ele √©, o AngularJS √© de 2010.

Apesar de ser t√£o novo, ele j√° fez um grande impacto, com uma base s√≥lida de f√£s e contribuidores. Tanto √© que o Google, por meio do programa [Aurora](https://developer.chrome.com/blog/introducing-aurora/), concedeu um financiamento de $30,000 para o Solid. E por que ele tem chamado tanta aten√ß√£o? Principalmente por sua performance.

<img src="/images/articles/welcome/solid-performance-comparison.png" alt="Foto contendo imagem disponibilizada no site do SolidJs onde mostram um teste de performance onde o Solid foi muito bem." />

O link para ver como foram feitos os testes de performance est√£o [aqui](https://github.com/krausest/js-framework-benchmark).

O Solid, assim como outras bibliotecas/frameworks, trabalha com a DOM para lidar com a reatividade. No entanto, ele n√£o precisa criar uma [VDOM](https://www.treinaweb.com.br/blog/o-que-e-dom-virtual-dom-e-shadow-dom) (Virtual DOM), o que melhora muito o desempenho. Isso elimina a necessidade de o cliente lidar com essa complexidade. E como ele faz isso? Com um conceito de [reatividade fina](https://www.solidjs.com/guides/reactivity).

A reatividade fina √© uma t√©cnica que permite que um componente renderize apenas os elementos que precisam ser atualizados quando o estado muda. Isso torna o componente muito mais eficiente do que componentes que precisam renderizar todos os elementos sempre que o estado muda.

O SolidJS alcan√ßa a reatividade fina usando uma t√©cnica chamada "sinais". Os sinais s√£o objetos que podem ser usados para conectar diferentes partes de um componente. Quando o valor de um sinal muda, todos os objetos conectados a esse sinal tamb√©m s√£o atualizados. Isso permite que o SolidJS atualize apenas os elementos que precisam ser atualizados quando o estado muda.

Por exemplo, se voc√™ tiver um componente com um bot√£o e um campo de texto, pode usar um sinal para conectar o bot√£o ao campo de texto. Quando o usu√°rio clicar no bot√£o, o sinal mudar√° e o campo de texto ser√° atualizado. Isso significa que o componente s√≥ precisar√° renderizar o campo de texto, n√£o todo o componente, o que tamb√©m elimina a preocupa√ß√£o com quantas vezes o componente ser√° renderizado, como acontece no React.

Algo interessante a mencionar √© que n√£o podemos desestruturar as props dos componentes no Solid, pois suas propriedades devem estar ligadas ao objeto props. Por baixo dos panos, as props s√£o um objeto de getters e setters. Se fizermos a desestrutura√ß√£o, podemos pegar apenas o valor primitivo e n√£o o retorno da fun√ß√£o getter.


```js
// Correto

const MyComponent = (props) => <div>{props.name}</div>;
```

```js
// Incorreto
const MyComponent = ({ name }) => <div>{name}</div>;
```

Com todas essas considera√ß√µes em mente, conhecendo o poder do Solid em rela√ß√£o a desempenho, tamanho reduzido de pacote, sua crescente comunidade e sua forte semelhan√ßa com o React, e tamb√©m levando em conta minha vontade de experimentar essa nova tecnologia, escolhi o Solid e n√£o me arrependo. Apesar deste site ainda ser pequeno e pouco reativo, pude aprender muito e desfrutar dessa experi√™ncia.

## [Tailwind](https://tailwindcss.com/)

Agora, depois de discutir tecnologias mais recentes que talvez voc√™ n√£o conhe√ßa, chegamos a uma biblioteca muito famosa no mundo web: o querido Tailwind CSS.

Minha escolha para usar essa biblioteca tamb√©m foi muito guiada pela performance e facilidade que ela oferece, al√©m de j√° trazer um design system pronto. Isso permitiu que eu fizesse altera√ß√µes r√°pidas e simples, podendo tamb√©m criar plugins facilmente integrados √† biblioteca.

O Tailwind traz uma s√©rie de classes utilit√°rias que facilitam muito a cria√ß√£o de estilos de maneira r√°pida e f√°cil. Junto com suas t√©cnicas de minifica√ß√£o e compress√£o, os arquivos em projetos grandes podem ser reduzidos para cerca de 10 KB.

Para ilustrar, aqui est√° um exemplo:

<img src="/images/articles/welcome/tailwind-example.png" alt="Exemplo de como o bundle do tailwind √© feito, removendo classes que n√£o utilizamos." />

## [MDX](https://mdxjs.com/)

O MDX √© possivelmente conhecido por muitos. Ele √© uma linguagem de marca√ß√£o semelhante ao MD (Markdown), mas tamb√©m permite o uso de componentes JSX. Normalmente, √© usada para criar posts de blogs, como este.

# Arquitetura

Para alguns iniciantes, pode parecer estranho ouvir a palavra "arquitetura" em um projeto front-end. No entanto, existem muitos tipos de arquiteturas a serem seguidas quando se tem a liberdade de escolher. Sim, h√° momentos em que o framework escolhido determina a regra a ser seguida, o que muitas vezes √© at√© melhor. Por exemplo, no React, muitas pessoas podem achar estranho misturar estiliza√ß√£o, l√≥gica do componente e o pr√≥prio componente em um s√≥ lugar. Isso pode resultar em componentes confusos e complexos.

Pensando nisso, eu quis experimentar o [Atomic Design](https://bradfrost.com/blog/post/atomic-web-design/). Antes de entrar em detalhes sobre o que √© o Atomic Design e mostrar um exemplo pr√°tico, √© importante entender o conceito.

O Atomic Design √© uma metodologia para criar designs consistentes. Ele nos ajuda a enxergar as coisas como elas realmente s√£o, refletindo o mundo real.

Essa metodologia divide os componentes em cinco tipos: `Atoms`, `Molecules`, `Organisms`, `Templates` e `Pages`. Quando voc√™ compreende o prop√≥sito de cada parte da sua UI, fica muito mais f√°cil organiz√°-las.

## Atoms

Os √°tomos s√£o, como na vida real, os componentes mais elementares da nossa UI. S√£o os elementos HTML individuais, como bot√µes, inputs e links. S√£o partes da nossa UI que podem funcionar de forma independente, sendo a menor granularidade poss√≠vel. N√£o √© poss√≠vel dividir um √°tomo em partes menores.

<img src="/images/articles/welcome/button.png" alt="Foto de um bot√£o exemplificando o que seria um √°tomo no Atomic Design." />

## Molecules

As mol√©culas s√£o jun√ß√µes de √°tomos que, quando combinadas, t√™m um prop√≥sito maior. Um exemplo disso √© o componente ArticleCard, utilizado aqui no meu site. Ele combina diferentes elementos HTML para formar um componente maior, que por si s√≥ expressa algo mais complexo. Se desmembr√°ssemos todos os √°tomos que comp√µem essa mol√©cula, ela perderia seu sentido.

<img src="/images/articles/welcome/article-card.png" alt="Foto de um card exemplificando o que seria uma mol√©cula no Atomic Design." />

## Organisms

Os organismos s√£o partes mais complexas da nossa UI. Eles normalmente s√£o compostos por mol√©culas, √°tomos ou at√© outros organismos. Eles contam uma hist√≥ria completa por si s√≥. Mesmo se retir√°ssemos todo o restante da UI e deix√°ssemos apenas um organismo, ainda assim conseguir√≠amos entender sua fun√ß√£o. Um exemplo √© a se√ß√£o de posts que temos aqui na p√°gina inicial.

<img src="/images/articles/welcome/article-section.png" alt="Foto de uma se√ß√£o do meu site exemplificando o que seria um organismo no Atomic Design." />

## Templates

Os templates s√£o um reflexo do que o usu√°rio ver√°, aguardando apenas os dados reais para serem renderizados. Eles representam uma p√°gina completa, mas sem os dados reais. Eles s√£o a UI completa, aguardando os dados para serem montados. Essa separa√ß√£o da l√≥gica do componente do restante da UI faz sentido em projetos maiores e mais complexos. Embora ainda n√£o tenha testado essa metodologia em um projeto din√¢mico, para um site est√°tico como este, ela se encaixou bem.

<img src="/images/articles/welcome/complete-example-of-atomic-design.png" width="900px" alt="Foto de todas as etapas do atomic design, exemplificando como vamos de um √°tomo at√© uma p√°gina completa." />

## Pages

As p√°ginas representam os templates com os dados reais. S√£o as p√°ginas completas que o usu√°rio v√™. Abaixo, uma imagem exemplifica uma p√°gina.

<img src="/images/articles/welcome/template-in-use-example.png" alt="Foto de uma p√°gina deste site exemplificando como um template ficaria com dados reais." />

## Layouts

Por √∫ltimo, menciono algo que n√£o abordei antes, pois √© uma adi√ß√£o espec√≠fica que fiz. S√£o os layouts, que criei para guardar a parte da UI presente em todos os templates. No nosso caso, isso inclui a parte superior do site, como pode ser visto na imagem abaixo.

<img src="/images/articles/welcome/layout-example.png" alt="Foto onde mostro uma parte adicional n√£o presente no Atomic Design que seriam os layouts, aqui nesta foto demonstrei o uso dele." />

# Infra

Por √∫ltimo, vale a pena mencionar como este site est√° sendo hospedado e como cuido do seu CI/CD.

√â simples: estou usando a [AWS](https://aws.amazon.com/pt/what-is-aws/) para tudo. Aqui est√° como funciona:

1. Tenho um dom√≠nio com o [Route 53](https://aws.amazon.com/pt/route53/), apontando para um [CloudFront](https://aws.amazon.com/pt/cloudfront/).
2. Quando o CloudFront recebe uma solicita√ß√£o, ele verifica o certificado SSM gerado pelo [ACM](https://aws.amazon.com/pt/certificate-manager/) (Amazon Certificate Manager).
3. O CloudFront aponta para um bucket no [S3](https://aws.amazon.com/pt/s3/), onde o site est√° hospedado estaticamente.

Abaixo, um diagrama que ilustra esse fluxo:

<img src="/images/articles/welcome/diagrama-blog-fluxo-de-trabalho.png" alt="Foto de um diagrama de fluxo de trabalho mostrando todas as etapas de como funciona para renderizar uma p√°gina deste site no seu navegador." />

Para controle de CI/CD, utilizo as [GitHub Actions](https://github.com/features/actions). Voc√™ pode conferir o arquivo `.github/workflows/deploy.yaml` no reposit√≥rio deste site.

# Conclus√£o

E assim terminamos por hoje. Havia mais algumas coisas que eu gostaria de mencionar, como a [gera√ß√£o de og:image](https://github.com/RobertDS07/blog#gera%C3%A7%C3%A3o-de-ogimage) para o site, mas achei que o post estava ficando muito longo. Este foi o primeiro de muitos, espero ter apresentado algo novo a voc√™ hoje, despertado o interesse em estudar algo que mencionei ou simplesmente espero que tenha gostado.

Este site est√° dispon√≠vel no GitHub. Se puder, deixe uma estrela üòâ, [clique aqui](https://github.com/RobertDS07/blog)